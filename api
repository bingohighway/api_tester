#!/bin/zsh

echo "Creating the updated API server file: api.py (with backend enforcement removed)..."

cat > api.py << 'EOF'
#!/usr/bin/env python3
import time, random, string, argparse, json, copy, re
from flask import Flask, request, jsonify, Response
from urllib.parse import unquote

parser = argparse.ArgumentParser(description='A versatile Flask Test API for evaluating WAFs and API Gateways.', formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('--timing-allow-origin', dest='tao', action='store_true', help='Include the Timing-Allow-Origin: * header in all responses.')
args = parser.parse_args()

app = Flask(__name__)

SUSPICIOUS_PATTERNS = {
    "SQLi Tautology": re.compile(r"'.*?OR.*?'\d+'\s*=\s*'\d+'", re.IGNORECASE),
    "SQLi Union": re.compile(r"UNION\s+SELECT", re.IGNORECASE),
    "Basic XSS": re.compile(r"<script.*?>.*?</script>", re.IGNORECASE),
    "Img XSS": re.compile(r"<img.*?src.*?onerror.*?>", re.IGNORECASE),
    "Path Traversal": re.compile(r"\.\./"),
    "Command Injection": re.compile(r"(&&|\|\||;|`)\s*(ls|cat|whoami|uname|ifconfig|ipconfig)", re.IGNORECASE),
}

API_CONTRACT = {
    # This section remains the same, defining the *intended* strict contracts
    "openapi": "3.0.0",
    "info": { "title": "WAF Test API", "version": "1.8.0", "description": "An API designed to test WAFs and API Gateways." },
    "paths": {
        "/fuzz-target-weak": { "post": { "summary": "Fuzzing target with a weak/loose contract.", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string"}}}}}}}},
        "/fuzz-target-strict": { "post": { "summary": "Fuzzing target with a strict (alphanumeric) contract.", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string", "pattern": "^[a-zA-Z0-9]+$"}}}}}}}},
        "/hex-decode-check": { "post": { "summary": "Decodes a hex string and checks for suspicious patterns.", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string", "pattern": "^[a-fA-F0-9]+$"}}}}}}}},
        "/url-decode-diagnostic": { "post": { "summary": "Decodes a URL-encoded string and returns a safe analysis.", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string"}}}}}}}},
        "/pattern-check": { "post": { "summary": "Checks input against suspicious patterns (loose contract).", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string"}}}}}}}},
        "/pattern-check-contract": { "post": { "summary": "Checks input against suspicious patterns (strict contract).", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string", "pattern": "^[a-zA-Z0-9]+$", "maxLength": 50}}}}}}}},
        "/usage": { "get": { "summary": "Provides a human-readable summary of all endpoints."}},
        "/delay/{milliseconds}": { "get": { "summary": "Delays the response by a specified time.", "parameters": [{"name": "milliseconds", "in": "path", "required": True, "schema": {"type": "integer", "minimum": 0, "maximum": 60000}}]}},
        "/chars-contract": { "post": { "summary": "Accepts only alphanumeric strings, enforced by contract.", "requestBody": {"required": True, "content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "string", "description": "Must contain only alphanumeric characters.","pattern": "^[a-zA-Z0-9]+$","maxLength": 50}}}}}}}}
    }
}

@app.after_request
def add_custom_headers(response):
    response.headers['Access-Control-Allow-Origin'] = '*';
    if args.tao: response.headers['Timing-Allow-Origin'] = '*'
    response.headers['X-Content-Type-Options'] = 'nosniff'; return response

# --- The endpoint functions below are now intentionally permissive ---

@app.route('/delay/<int:milliseconds>')
def delay(milliseconds):
    # REMOVED: Enforcement logic that checked if milliseconds > 60000.
    # The API will now wait for any amount of time to test gateway timeouts.
    time.sleep(milliseconds / 1000.0)
    return jsonify({"status": "success", "delay_ms": milliseconds})

@app.route('/tight-echo', methods=['POST'])
def tight_echo():
    data = request.json.get('data', '')
    # REMOVED: Enforcement logic that checked len(data).
    # This endpoint will now echo any data it receives, regardless of length or type.
    return jsonify({"echo": data})

@app.route('/loose-echo', methods=['POST'])
def loose_echo():
    data = request.json.get('data', '')
    # REMOVED: Enforcement logic that checked len(data).
    return jsonify({"echo": data})

@app.route('/random')
def random_string():
    # REMOVED: Enforcement logic that checked if length > 1000.
    # The API will now generate a string of any requested length.
    try: length = int(request.args.get('length', 10))
    except (ValueError, TypeError): return jsonify({"error": "Invalid length parameter."}), 400
    return jsonify({"random_string": ''.join(random.choice(string.ascii_letters+string.digits) for _ in range(length)), "length": length})

@app.route('/chars-contract', methods=['POST'])
def chars_contract():
    # MODIFIED: Logic is now fully permissive.
    # This function no longer checks if the data is alphanumeric. It accepts anything.
    # This makes it a pure test of the gateway's contract enforcement.
    data = request.json.get('data')
    return jsonify({"status": "success", "message": "data received by API", "data_received": data})

# ... (Other endpoints like fuzz targets and diagnostic tools were already permissive and remain unchanged) ...
@app.route('/fuzz-target-weak', methods=['POST'])
def fuzz_target_weak():
    data = request.json.get('data', '')
    for name, pattern in SUSPICIOUS_PATTERNS.items():
        if pattern.search(data):
            return jsonify({"status": "pattern_received", "pattern_name": name})
    return jsonify({"status": "pattern_not_recognized"})
@app.route('/fuzz-target-strict', methods=['POST'])
def fuzz_target_strict():
    data = request.json.get('data', '')
    for name, pattern in SUSPICIOUS_PATTERNS.items():
        if pattern.search(data):
            return jsonify({"status": "pattern_received", "pattern_name": name})
    return jsonify({"status": "pattern_not_recognized"})
@app.route('/')
def index(): return jsonify({"message": "Welcome. See /usage for details."})
@app.route('/usage')
def usage():
    # This is a simplified helper, in a real app this would be more robust
    return jsonify(API_CONTRACT['paths'])
@app.route('/url-decode-diagnostic', methods=['POST'])
def url_decode_diagnostic():
    encoded_data = request.json.get('data', ''); decoded_string = unquote(encoded_data)
    analysis = {"contains_single_quote": "'" in decoded_string, "contains_space": " " in decoded_string}
    return jsonify({"status": "analysis_complete", "decoded_length": len(decoded_string), "analysis": analysis})
@app.route('/hex-decode-check', methods=['POST'])
def hex_decode_check():
    hex_data = request.json.get('data','');
    try: decoded_bytes = bytes.fromhex(hex_data); decoded_string = decoded_bytes.decode('utf-8', errors='ignore')
    except (ValueError,TypeError): return jsonify({"error":"Invalid hex"}),400
    for n,p in SUSPICIOUS_PATTERNS.items():
        if p.search(decoded_string): return jsonify({"status":"match_found_after_decode","pattern_name":n})
    return jsonify({"status":"no_match_found_after_decode"})
@app.route('/pattern-check', methods=['POST'])
def pattern_check():
    data = request.json.get('data', '');
    if not isinstance(data, str): return jsonify({"error": "Invalid input format"}), 400
    for name, pattern in SUSPICIOUS_PATTERNS.items():
        if pattern.search(data): return jsonify({"status": "match_found", "pattern_name": name})
    return jsonify({"status": "no_match_found"})
@app.route('/pattern-check-contract', methods=['POST'])
def pattern_check_contract():
    data = request.json.get('data', '');
    if not isinstance(data, str): return jsonify({"error": "Invalid input format"}), 400
    for name, pattern in SUSPICIOUS_PATTERNS.items():
        if pattern.search(data): return jsonify({"status": "match_found", "pattern_name": name})
    return jsonify({"status": "no_match_found"})
@app.route('/headers')
def headers(): return jsonify({key: value for key, value in request.headers.items()})
@app.route('/response-code/<int:code>')
def response_code(code):
    return Response(f"Response with code {code}", status=code)

if __name__ == '__main__':
    app.run(debug=True, port=5000)
EOF

echo "\napi.py has been updated."
echo "All backend contract enforcement logic has been removed to create a pure test target for your WAF/Gateway."
